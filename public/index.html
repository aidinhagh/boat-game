<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <!-- Import Telegram Web App Script -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <title>High Seas Extraction: Night Ops</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #0d1a2b; font-family: 'Segoe UI', sans-serif; user-select: none; -webkit-touch-callout: none; }
        #game-container { position: relative; width: 100vw; height: 100vh; overflow: hidden; outline: none; } /* Added outline:none for focus */
        canvas { display: block; width: 100%; height: 100%; touch-action: none; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; padding: 20px; box-sizing: border-box; display: flex; flex-direction: column; justify-content: space-between; }
        .hud-top { display: flex; justify-content: space-between; align-items: flex-start; width: 100%; }
        .status-panel { position: relative; width: 300px; max-width: 45%; background: linear-gradient(135deg, rgba(0, 40, 80, 0.8) 0%, rgba(0, 10, 20, 0.6) 100%); border: 1px solid #005577; border-left: 4px solid #00ccff; padding: 10px 15px; transform: skewX(-10deg); box-shadow: 0 0 15px rgba(0, 200, 255, 0.2); }
        .status-label { color: #00ccff; font-size: 10px; letter-spacing: 2px; text-transform: uppercase; margin-bottom: 5px; transform: skewX(10deg); font-weight: bold; }
        .hp-track { width: 100%; height: 12px; background: rgba(0,0,0,0.5); border: 1px solid #333; transform: skewX(10deg); overflow: hidden; position: relative; }
        .hp-fill { height: 100%; width: 100%; background: linear-gradient(90deg, #ff4444, #ff0000); box-shadow: 0 0 10px #ff0000; transition: width 0.1s; }
        .timer-panel { background: linear-gradient(135deg, rgba(60, 30, 0, 0.8) 0%, rgba(20, 10, 0, 0.6) 100%); border: 1px solid #774400; border-right: 4px solid #ffaa00; padding: 10px 20px; transform: skewX(10deg); color: #ffaa00; text-align: center; box-shadow: 0 0 15px rgba(255, 170, 0, 0.2); }
        #timer { font-family: 'Courier New', monospace; font-size: 28px; font-weight: 900; transform: skewX(-10deg); text-shadow: 0 0 5px rgba(255, 170, 0, 0.5); }
        .timer-label { font-size: 10px; text-transform: uppercase; letter-spacing: 2px; transform: skewX(-10deg); opacity: 0.8; }
        .screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(10, 20, 30, 0.85); backdrop-filter: blur(8px); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 30; color: white; opacity: 0; pointer-events: none; transition: opacity 0.4s; text-align: center; padding: 20px; box-sizing: border-box; }
        .screen.active { opacity: 1; pointer-events: all; }
        h1 { font-size: clamp(2.5em, 8vw, 4em); text-transform: uppercase; letter-spacing: 4px; background: linear-gradient(to bottom, #fff, #aaccff); -webkit-background-clip: text; -webkit-text-fill-color: transparent; margin: 0 0 20px 0; text-shadow: 0 10px 20px rgba(0,0,0,0.5); text-align: center; }
        .controls-hint { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; background: rgba(255,255,255,0.1); padding: 20px 40px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.2); margin-bottom: 30px; font-family: monospace; font-size: 1.1em; }
        @media (hover: none) and (pointer: coarse) { .desktop-hint { display: none; } .mobile-hint { display: block; } }
        @media (hover: hover) { .mobile-hint { display: none; } }
        button { background: transparent; color: #00ccff; border: 2px solid #00ccff; padding: 15px 50px; font-size: 18px; font-weight: bold; text-transform: uppercase; letter-spacing: 3px; cursor: pointer; transition: 0.2s; position: relative; overflow: hidden; border-radius: 4px; }
        button:hover { background: #00ccff; color: #000; box-shadow: 0 0 20px #00ccff; }
        #damage-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; box-shadow: inset 0 0 0 0 rgba(255,0,0,0); pointer-events: none; transition: box-shadow 0.1s; z-index: 5; }
        #mobile-controls { display: none; position: absolute; bottom: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 20; }
        @media (hover: none) and (pointer: coarse) { #mobile-controls { display: block; } }
        .control-group-left { position: absolute; bottom: 30px; left: 30px; display: flex; gap: 20px; pointer-events: auto; }
        .control-btn { width: 90px; height: 90px; background: rgba(0, 150, 255, 0.15); border: 2px solid rgba(100, 200, 255, 0.5); border-radius: 50%; display: flex; justify-content: center; align-items: center; color: rgba(255, 255, 255, 1); font-size: 40px; user-select: none; backdrop-filter: blur(4px); touch-action: none; }
        .control-btn:active { background: rgba(0, 204, 255, 0.5); transform: scale(0.95); }
        .joystick-zone-right { position: absolute; top: 0; bottom: 0; right: 0; width: 50%; pointer-events: auto; }
        .aim-hint-text { position: absolute; bottom: 40px; right: 40px; color: rgba(255,255,255,0.5); font-size: 14px; pointer-events: none; text-align: right; text-shadow: 0 1px 2px black; }
        #joystick-visual { position: absolute; width: 60px; height: 60px; border: 2px solid rgba(255,255,255,0.5); border-radius: 50%; pointer-events: none; display: none; transform: translate(-50%, -50%); }
        #joystick-knob { position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; background: rgba(255,255,255,0.8); border-radius: 50%; transform: translate(-50%, -50%); }
        #user-info { position: absolute; bottom: 10px; right: 10px; color: rgba(255,255,255,0.3); font-size: 12px; pointer-events: none; }
    </style>
</head>
<body>
<!-- Added tabindex to make div focusable for keyboard events -->
<div id="game-container" tabindex="0">
    <canvas id="canvas"></canvas>
    <div id="damage-overlay"></div>
    <div id="ui-layer">
        <div class="hud-top">
            <div class="status-panel">
                <div class="status-label">Hull Integrity</div>
                <div class="hp-track"><div id="hp-bar" class="hp-fill"></div></div>
            </div>
            <div class="timer-panel">
                <div class="timer-label">Extraction In</div>
                <div id="timer">02:00</div>
            </div>
        </div>
        <div id="user-info"></div>
    </div>
    <div id="mobile-controls">
        <div class="control-group-left">
            <div id="btn-left" class="control-btn">◄</div>
            <div id="btn-right" class="control-btn">►</div>
        </div>
        <div id="aim-zone" class="joystick-zone-right"></div>
        <div class="aim-hint-text">TOUCH & DRAG TO AIM</div>
        <div id="joystick-visual"><div id="joystick-knob"></div></div>
    </div>
    <div id="start-screen" class="screen active">
        <h1>Night Extraction</h1>
        <p style="color: #ccc; margin-bottom: 30px; letter-spacing: 1px; font-weight: bold;">THE ENGINE IS LOCKED AT MAX CRUISE.<br>SURVIVE THE PURSUIT.</p>
        <div class="controls-hint desktop-hint"><div>[MOUSE] AIM & SHOOT</div><div>[A / D] STEER</div></div>
        <div class="controls-hint mobile-hint"><div>[LEFT] STEER</div><div>[RIGHT] DRAG TO SHOOT</div></div>
        <button onclick="game.start()">INITIATE SEQUENCE</button>
    </div>
    <div id="end-screen" class="screen">
        <h1 id="end-title">MIA</h1>
        <p id="end-reason" style="color:#ddd; font-size: 1.2em; margin-bottom: 30px;">SIGNAL LOST</p>
        <button onclick="game.restart()">RETRY MISSION</button>
    </div>
</div>
<script>
const rnd=(min,max)=>Math.random()*(max-min)+min;
const clamp=(val,min,max)=>Math.min(Math.max(val,min),max);

// TELEGRAM INIT
let tgUser = null;
if (window.Telegram && window.Telegram.WebApp) {
    const webApp = window.Telegram.WebApp;
    webApp.ready();
    webApp.expand(); // Force expand on open
    tgUser = webApp.initDataUnsafe ? webApp.initDataUnsafe.user : null;
    if(tgUser) {
        document.getElementById('user-info').innerText = `Operative: ${tgUser.first_name}`;
    }
}

class Game {
    constructor() {
        this.canvas = document.getElementById('canvas');
        this.container = document.getElementById('game-container');
        this.ctx = this.canvas.getContext('2d', { alpha: false }); 
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.running = false;
        this.entities = [];
        this.particles = [];
        this.mist = [];
        this.camera = { x: 0, y: 0, shake: 0 };
        this.input = { x: 0, y: 0, keys: {}, mouse: { x: 0, y: 0, down: false } };
        this.timeLeft = 120;
        this.spawnTimer = 0;
        this.joystick = { active: false, originX: 0, originY: 0, currentX: 0, currentY: 0, id: null };
        window.addEventListener('resize', () => this.resize());
        this.resize();
        
        // --- CONTROLS FIX ---
        // Listen on window, but also force focus on the container
        window.addEventListener('keydown', e => this.input.keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => this.input.keys[e.key.toLowerCase()] = false);
        
        // Mouse/Touch
        window.addEventListener('mousemove', e => { if (!this.joystick.active) { this.input.mouse.x = e.clientX; this.input.mouse.y = e.clientY; } });
        window.addEventListener('mousedown', () => { 
            this.input.mouse.down = true; 
            // Force focus for keyboard controls inside iframes/webviews
            window.focus(); 
            this.container.focus();
        });
        window.addEventListener('mouseup', () => this.input.mouse.down = false);
        this.setupTouchControls();
    }

    setupTouchControls() {
        const btnLeft = document.getElementById('btn-left');
        const btnRight = document.getElementById('btn-right');
        const handleSteer = (key, active) => { this.input.keys[key] = active; };
        btnLeft.addEventListener('touchstart', (e) => { e.preventDefault(); handleSteer('a', true); });
        btnLeft.addEventListener('touchend', (e) => { e.preventDefault(); handleSteer('a', false); });
        btnRight.addEventListener('touchstart', (e) => { e.preventDefault(); handleSteer('d', true); });
        btnRight.addEventListener('touchend', (e) => { e.preventDefault(); handleSteer('d', false); });
        const aimZone = document.getElementById('aim-zone');
        const visual = document.getElementById('joystick-visual');
        const knob = document.getElementById('joystick-knob');
        aimZone.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (this.joystick.active) return;
            const t = e.changedTouches[0];
            this.joystick.active = true;
            this.joystick.id = t.identifier;
            this.joystick.originX = t.clientX;
            this.joystick.originY = t.clientY;
            this.joystick.currentX = t.clientX;
            this.joystick.currentY = t.clientY;
            visual.style.display = 'block';
            visual.style.left = t.clientX + 'px';
            visual.style.top = t.clientY + 'px';
            knob.style.transform = `translate(-50%, -50%)`;
            this.input.mouse.down = true;
        }, { passive: false });
        aimZone.addEventListener('touchmove', (e) => {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                if (t.identifier === this.joystick.id) {
                    this.joystick.currentX = t.clientX;
                    this.joystick.currentY = t.clientY;
                    const dx = t.clientX - this.joystick.originX;
                    const dy = t.clientY - this.joystick.originY;
                    const dist = Math.hypot(dx, dy);
                    const angle = Math.atan2(dy, dx);
                    const kx = Math.cos(angle) * Math.min(dist, 30);
                    const ky = Math.sin(angle) * Math.min(dist, 30);
                    knob.style.transform = `translate(calc(-50% + ${kx}px), calc(-50% + ${ky}px))`;
                }
            }
        }, { passive: false });
        const endJoystick = (e) => {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === this.joystick.id) {
                    this.joystick.active = false; this.joystick.id = null; this.input.mouse.down = false; visual.style.display = 'none';
                }
            }
        };
        aimZone.addEventListener('touchend', endJoystick);
        aimZone.addEventListener('touchcancel', endJoystick);
    }
    resize() { this.width = this.canvas.width = window.innerWidth; this.height = this.canvas.height = window.innerHeight; }
    start() {
        document.getElementById('start-screen').classList.remove('active');
        document.getElementById('end-screen').classList.remove('active');
        // Force focus on start for keyboard
        window.focus();
        this.container.focus();

        this.entities = []; this.particles = []; this.mist = [];
        this.player = new Player(0, 0); this.entities.push(this.player);
        this.timeLeft = 120; this.spawnTimer = 0; this.running = true;
        for(let i=0; i<20; i++) { this.addMist(true); }
        this.lastTime = performance.now();
        requestAnimationFrame(t => this.loop(t));
    }
    restart() { this.start(); }
    
    // --- TELEGRAM INTEGRATION ---
    async sendResultToTelegram(won, reason) {
        if(this.sent) return;
        this.sent = true;

        let playerInfo = { type: 'Anonymous (Browser)', id: 'N/A', name: 'N/A' };
        if (tgUser) {
            playerInfo = {
                type: 'Telegram User',
                id: tgUser.id,
                username: tgUser.username ? `@${tgUser.username}` : 'N/A',
                name: `${tgUser.first_name} ${tgUser.last_name || ''}`.trim()
            };
        }

        try {
            await fetch('/api/submit-score', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ won, reason, timeLeft: Math.floor(this.timeLeft), player: playerInfo })
            });
        } catch(e) { console.log('Telegram API Error'); }
    }

    end(won) {
        this.running = false;
        const screen = document.getElementById('end-screen');
        const title = document.getElementById('end-title');
        const reason = document.getElementById('end-reason');
        screen.classList.add('active');
        if (won) {
            title.innerText = "MISSION COMPLETE"; title.style.webkitTextFillColor = "#00ff44"; reason.innerText = "You escaped the perimeter.";
        } else {
            title.innerText = "KILLED IN ACTION"; title.style.webkitTextFillColor = "#ff3333"; reason.innerText = "The boat was destroyed.";
        }
        this.sent = false; 
        this.sendResultToTelegram(won, reason.innerText);
    }
    spawnEnemy() {
        const count = rnd(1, 10) > 7 ? 2 : 1; 
        for(let i=0; i<count; i++) {
            const angle = rnd(0, Math.PI * 2); const dist = rnd(1200, 1600); 
            const x = this.player.x + Math.cos(angle) * dist; const y = this.player.y + Math.sin(angle) * dist;
            this.entities.push(new Enemy(x, y));
        }
    }
    addMist(randomPos = false) {
        const angle = rnd(0, Math.PI * 2); const cx = this.camera.x + this.width/2; const cy = this.camera.y + this.height/2;
        let x, y;
        if (randomPos) { x = cx + rnd(-this.width, this.width); y = cy + rnd(-this.height, this.height); } else {
            const spawnDist = Math.max(this.width, this.height); x = cx + Math.cos(angle) * spawnDist; y = cy + Math.sin(angle) * spawnDist;
        }
        this.mist.push({ x: x, y: y, vx: rnd(-20, 20), vy: rnd(-20, 20), size: rnd(300, 600), life: 1.0, decay: rnd(0.05, 0.1) });
    }
    update(dt) {
        this.timeLeft -= dt; if (this.timeLeft <= 0) { this.end(true); return; }
        this.spawnTimer -= dt; if (this.spawnTimer <= 0) {
            let spawnRate = 2.5; if (this.timeLeft < 60) spawnRate = 2.0; if (this.timeLeft < 30) spawnRate = 1.5;
            this.spawnEnemy(); this.spawnTimer = spawnRate;
        }
        if (Math.random() > 0.9) this.addMist();
        for (let i = this.mist.length - 1; i >= 0; i--) {
            let m = this.mist[i]; m.x += m.vx * dt; m.y += m.vy * dt; m.life -= m.decay * dt * 0.1; if (m.life <= 0) this.mist.splice(i, 1);
        }
        for (let i = this.entities.length - 1; i >= 0; i--) { const e = this.entities[i]; e.update(dt, this); if (e.dead) this.entities.splice(i, 1); }
        for (let i = this.particles.length - 1; i >= 0; i--) { const p = this.particles[i]; p.update(dt); if (p.life <= 0) this.particles.splice(i, 1); }
        const targetX = this.player.x - this.width / 2; const targetY = this.player.y - this.height / 2;
        this.camera.x += (targetX - this.camera.x) * 0.1; this.camera.y += (targetY - this.camera.y) * 0.1;
        if (this.camera.shake > 0) { this.camera.shake -= dt * 30; if (this.camera.shake < 0) this.camera.shake = 0; }
        const mins = Math.floor(this.timeLeft / 60); const secs = Math.floor(this.timeLeft % 60);
        document.getElementById('timer').innerText = `${mins}:${secs.toString().padStart(2, '0')}`;
        document.getElementById('hp-bar').style.width = `${Math.max(0, this.player.hp)}%`;
        const overlay = document.getElementById('damage-overlay');
        if (this.player.hitFlash > 0) { overlay.style.boxShadow = `inset 0 0 50px 20px rgba(255,0,0,0.4)`; this.player.hitFlash--; } else { overlay.style.boxShadow = `inset 0 0 0 0 rgba(255,0,0,0)`; }
    }
    draw() {
        const ctx = this.ctx; const sx = (Math.random() - 0.5) * this.camera.shake; const sy = (Math.random() - 0.5) * this.camera.shake;
        ctx.setTransform(1, 0, 0, 1, -this.camera.x + sx, -this.camera.y + sy);
        this.drawWater();
        ctx.save();
        this.entities.forEach(e => {
            if (!e.dead && !(e instanceof Bullet)) {
                ctx.save(); ctx.translate(e.x - 10, e.y + 15); ctx.scale(1, 1); ctx.globalAlpha = 0.2; ctx.filter = 'blur(3px)'; ctx.translate(-e.x, -e.y); e.draw(ctx, true); ctx.restore();
            }
        });
        ctx.restore();
        ctx.globalCompositeOperation = 'screen'; this.particles.forEach(p => { if (p.layer === 0) p.draw(ctx); }); ctx.globalCompositeOperation = 'source-over';
        this.entities.forEach(e => e.draw(ctx, false));
        this.particles.forEach(p => { if (p.layer === 1) p.draw(ctx); });
        this.drawMist(ctx); this.drawLighting(ctx);
        ctx.setTransform(1, 0, 0, 1, 0, 0);
    }
    drawWater() {
        const ctx = this.ctx; const cx = this.camera.x; const cy = this.camera.y; const time = Date.now() / 1000;
        ctx.fillStyle = '#0d1a2b'; ctx.fillRect(cx, cy, this.width, this.height);
        ctx.strokeStyle = '#1a3350'; ctx.lineWidth = 3; ctx.beginPath();
        const swellGap = 150; const startY = Math.floor(cy / swellGap) * swellGap;
        for (let y = startY; y < cy + this.height + swellGap; y += swellGap) { const waveShift = Math.sin(y * 0.002 + time * 0.8) * 40; ctx.moveTo(cx, y + waveShift); ctx.lineTo(cx + this.width, y + waveShift + Math.sin((cx+this.width)*0.001 + time)*40); } ctx.stroke();
        ctx.fillStyle = 'rgba(60, 120, 180, 0.2)'; const chopGap = 80; const startX_c = Math.floor(cx / chopGap) * chopGap; const startY_c = Math.floor(cy / chopGap) * chopGap;
        for (let x = startX_c; x < cx + this.width + chopGap; x += chopGap) { for (let y = startY_c; y < cy + this.height + chopGap; y += chopGap) { const offX = Math.cos(x * 0.01 + time) * 20; const offY = Math.sin(y * 0.01 + time) * 20; if ((Math.abs(x)+Math.abs(y)) % 3 === 0) { ctx.beginPath(); ctx.arc(x + offX, y + offY, rnd(3,6), 0, Math.PI*2); ctx.fill(); } } }
        ctx.fillStyle = 'rgba(180, 220, 255, 0.2)'; const foamGap = 120; const startX_f = Math.floor(cx / foamGap) * foamGap; const startY_f = Math.floor(cy / foamGap) * foamGap;
        for (let x = startX_f; x < cx + this.width + foamGap; x += foamGap) { for (let y = startY_f; y < cy + this.height + foamGap; y += foamGap) { const waveHeight = Math.sin(x * 0.02 + time * 1.5) + Math.cos(y * 0.02 + time * 1.2); if (waveHeight > 1.2) { const size = (waveHeight - 1.0) * 15; ctx.beginPath(); ctx.ellipse(x, y, size * 2, size * 0.5, 0, 0, Math.PI*2); ctx.fill(); } } }
    }
    drawMist(ctx) { ctx.save(); ctx.globalCompositeOperation = 'screen'; this.mist.forEach(m => { const grad = ctx.createRadialGradient(m.x, m.y, 0, m.x, m.y, m.size); grad.addColorStop(0, `rgba(180, 210, 230, ${m.life * 0.1})`); grad.addColorStop(1, 'rgba(0,0,0,0)'); ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(m.x, m.y, m.size, 0, Math.PI*2); ctx.fill(); }); ctx.restore(); }
    drawLighting(ctx) {
        ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.fillStyle = 'rgba(0, 10, 30, 0.2)'; ctx.fillRect(0, 0, this.width, this.height);
        ctx.setTransform(1, 0, 0, 1, -this.camera.x, -this.camera.y); ctx.globalCompositeOperation = 'lighter';
        this.entities.forEach(e => {
            if (e.dead) return;
            if (e.team === 'player') {
                const grad = ctx.createRadialGradient(e.x, e.y, 20, e.x + Math.cos(e.angle)*200, e.y + Math.sin(e.angle)*200, 400); grad.addColorStop(0, 'rgba(220, 255, 255, 0.4)'); grad.addColorStop(1, 'rgba(0,0,0,0)'); ctx.save(); ctx.translate(e.x, e.y); ctx.rotate(e.angle); ctx.fillStyle = grad; ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0, 0, 500, -0.6, 0.6); ctx.fill(); ctx.restore();
            }
            if (e.team === 'enemy') {
                const color = Math.sin(Date.now() / 100) > 0 ? 'rgba(255, 50, 50, 0.4)' : 'rgba(50, 100, 255, 0.4)'; const grad = ctx.createRadialGradient(e.x, e.y, 10, e.x, e.y, 150); grad.addColorStop(0, color); grad.addColorStop(1, 'rgba(0,0,0,0)'); ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(e.x, e.y, 150, 0, Math.PI*2); ctx.fill();
            }
            if (e instanceof Bullet) {
                const grad = ctx.createRadialGradient(e.x, e.y, 2, e.x, e.y, 50); grad.addColorStop(0, 'rgba(255, 220, 100, 0.6)'); grad.addColorStop(1, 'rgba(0,0,0,0)'); ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(e.x, e.y, 50, 0, Math.PI*2); ctx.fill();
            }
        });
        ctx.globalCompositeOperation = 'source-over';
    }
    addParticle(type, x, y, angle, speed) { this.particles.push(new Particle(type, x, y, angle, speed)); }
    loop(now) { if (!this.running) return; const dt = Math.min((now - this.lastTime) / 1000, 0.1); this.lastTime = now; this.update(dt); this.draw(); requestAnimationFrame(t => this.loop(t)); }
}
class Entity { constructor(x, y) { this.x = x; this.y = y; this.vx = 0; this.vy = 0; this.angle = 0; this.radius = 20; this.dead = false; this.team = 'neutral'; } physics(dt) { this.x += this.vx * dt * 60; this.y += this.vy * dt * 60; } }
class Player extends Entity {
    constructor(x, y) { super(x, y); this.hp = 100; this.hitFlash = 0; this.speed = 10; this.team = 'player'; this.turretAngle = 0; this.lastShot = 0; }
    update(dt, game) {
        const keys = game.input.keys;
        if (keys['a'] || keys['arrowleft']) this.angle -= 0.06; if (keys['d'] || keys['arrowright']) this.angle += 0.06;
        this.vx = Math.cos(this.angle) * this.speed; this.vy = Math.sin(this.angle) * this.speed; this.physics(dt);
        if (Math.random() > 0.3) { const off = Math.PI/2; const wx = this.x - Math.cos(this.angle)*25; const wy = this.y - Math.sin(this.angle)*25; game.addParticle('wake', wx + Math.cos(this.angle+off)*10, wy + Math.sin(this.angle+off)*10, this.angle+Math.PI, 0); game.addParticle('wake', wx - Math.cos(this.angle+off)*10, wy - Math.sin(this.angle+off)*10, this.angle+Math.PI, 0); }
        if (game.joystick.active) {
            const dx = game.joystick.currentX - game.joystick.originX; const dy = game.joystick.currentY - game.joystick.originY; if (Math.hypot(dx, dy) > 5) { this.turretAngle = Math.atan2(dy, dx); }
        } else {
            const mx = game.input.mouse.x + game.camera.x; const my = game.input.mouse.y + game.camera.y; this.turretAngle = Math.atan2(my - this.y, mx - this.x);
        }
        if (game.input.mouse.down && Date.now() - this.lastShot > 120) { game.entities.push(new Bullet(this.x, this.y, this.turretAngle, this.team)); this.lastShot = Date.now(); game.camera.shake += 2; }
        if (this.hp <= 0) { this.dead = true; game.end(false); }
    }
    // NEW PLAYER SPRITE
    draw(ctx, isReflection) {
        ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle); 
        ctx.fillStyle = isReflection ? '#000' : '#e0e0e0';
        
        // Speedboat Hull
        ctx.beginPath();
        ctx.moveTo(40, 0); // Nose
        ctx.quadraticCurveTo(10, 20, -30, 18); // Right side curve
        ctx.lineTo(-30, -18); // Stern
        ctx.quadraticCurveTo(10, -20, 40, 0); // Left side curve
        ctx.closePath();
        ctx.fill();

        if (!isReflection) {
            // Windshield
            ctx.fillStyle = '#1a2b3c';
            ctx.beginPath();
            ctx.moveTo(5, 0);
            ctx.lineTo(-10, 12);
            ctx.lineTo(-5, 0);
            ctx.lineTo(-10, -12);
            ctx.closePath();
            ctx.fill();
            
            // Engine vents
            ctx.fillStyle = '#888';
            ctx.fillRect(-28, -8, 6, 16);
        }
        ctx.restore();

        // Turret
        ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.turretAngle); 
        ctx.fillStyle = isReflection ? '#000' : '#445'; 
        ctx.beginPath(); ctx.rect(0, -3, 30, 6); ctx.arc(0, 0, 8, 0, Math.PI*2); ctx.fill(); 
        ctx.restore();
    }
}
class Enemy extends Entity {
    // Reduced Fire Rate: Can shoot time increased, Cooldown increased
    constructor(x, y) { super(x, y); this.hp = 30; this.speed = rnd(11, 13); this.team = 'enemy'; this.canShootTime = Date.now() + 3000; this.lastShot = Date.now(); }
    update(dt, game) {
        const p = game.player; if (!p || p.dead) return;
        const dist = Math.hypot(p.x - this.x, p.y - this.y); const angleToP = Math.atan2(p.y - this.y, p.x - this.x);
        let angleDiff = angleToP - this.angle; while (angleDiff < -Math.PI) angleDiff += Math.PI * 2; while (angleDiff > Math.PI) angleDiff -= Math.PI * 2; this.angle += clamp(angleDiff, -0.05, 0.05);
        this.vx = Math.cos(this.angle) * this.speed; this.vy = Math.sin(this.angle) * this.speed; this.physics(dt);
        if (Math.random() > 0.6) { game.addParticle('wake', this.x, this.y, this.angle + Math.PI, 0); }
        const onScreen = this.x > game.camera.x && this.x < game.camera.x + game.width && this.y > game.camera.y && this.y < game.camera.y + game.height;
        
        // REDUCED FIRE RATE: shoot every 2500ms instead of 1000ms
        if (Date.now() > this.canShootTime && onScreen && dist < 500 && Math.abs(angleDiff) < 0.5) {
            if (Date.now() - this.lastShot > 2500) { game.entities.push(new Bullet(this.x, this.y, this.angle, this.team)); this.lastShot = Date.now(); }
        }
        if (dist < 60) { p.hp -= 5; p.hitFlash = 5; this.hp = 0; game.camera.shake += 15; for(let k=0; k<15; k++) game.addParticle('fire', this.x, this.y, rnd(0, 6.28), rnd(2,8)); }
        for (let other of game.entities) {
            if (other !== this && other.team === 'enemy' && !other.dead) {
                const d = Math.hypot(this.x - other.x, this.y - other.y);
                if (d < 60) { this.hp = 0; other.hp = 0; this.dead = true; other.dead = true; game.camera.shake += 20; for(let k=0; k<20; k++) game.addParticle('fire', this.x, this.y, rnd(0, 6.28), rnd(3, 10)); for(let k=0; k<20; k++) game.addParticle('fire', other.x, other.y, rnd(0, 6.28), rnd(3, 10)); for(let k=0; k<15; k++) game.addParticle('smoke', this.x, this.y, rnd(0, 6.28), rnd(2, 6)); }
            }
        }
        if (this.hp <= 0) { this.dead = true; for(let k=0; k<20; k++) game.addParticle('fire', this.x, this.y, rnd(0, 6.28), rnd(2,8)); for(let k=0; k<15; k++) game.addParticle('smoke', this.x, this.y, rnd(0, 6.28), rnd(1,5)); }
    }
    // NEW ENEMY SPRITE
    draw(ctx, isReflection) {
        ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle); 
        ctx.fillStyle = isReflection ? '#000' : '#222';
        
        // Patrol Boat Hull (RHIB style)
        ctx.beginPath();
        ctx.moveTo(35, 0);
        ctx.lineTo(20, 15); // Wide bow
        ctx.lineTo(-25, 15);
        ctx.lineTo(-25, -15);
        ctx.lineTo(20, -15);
        ctx.closePath();
        ctx.fill();

        if (!isReflection) {
            // Reinforced bumper
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 4;
            ctx.stroke();

            // Light bar
            if (Math.floor(Date.now() / 100) % 2 === 0) {
                ctx.fillStyle = 'red'; ctx.beginPath(); ctx.arc(-5, -10, 4, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = 'blue'; ctx.beginPath(); ctx.arc(-5, 10, 4, 0, Math.PI*2); ctx.fill();
            } else {
                ctx.fillStyle = 'blue'; ctx.beginPath(); ctx.arc(-5, -10, 4, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = 'red'; ctx.beginPath(); ctx.arc(-5, 10, 4, 0, Math.PI*2); ctx.fill();
            }
        }
        ctx.restore();
    }
}
class Bullet extends Entity {
    constructor(x, y, angle, owner) { super(x, y); this.angle = angle; this.vx = Math.cos(angle) * 22; this.vy = Math.sin(angle) * 22; this.owner = owner; this.life = 1.5; }
    update(dt, game) {
        this.x += this.vx * dt * 60; this.y += this.vy * dt * 60; this.life -= dt; if (this.life <= 0) { this.dead = true; return; }
        if (Math.random() > 0.5) game.addParticle('fire', this.x, this.y, 0, 0);
        if (this.owner === 'player') {
            for (let e of game.entities) { if (e.team === 'enemy' && !e.dead) { if (Math.hypot(this.x - e.x, this.y - e.y) < 40) { e.hp -= 15; this.dead = true; game.addParticle('fire', this.x, this.y, 0, 0); break; } } }
        } else {
            const p = game.player; if (!p.dead && Math.hypot(this.x - p.x, this.y - p.y) < 40) { p.hp -= 5; p.hitFlash = 3; this.dead = true; game.camera.shake += 4; game.addParticle('fire', this.x, this.y, 0, 0); }
        }
    }
    draw(ctx, isReflection) { ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle); ctx.fillStyle = this.owner === 'player' ? '#ffcc00' : '#ff5500'; ctx.beginPath(); ctx.moveTo(15, 0); ctx.lineTo(-15, 0); ctx.lineWidth = 4; ctx.strokeStyle = ctx.fillStyle; ctx.stroke(); ctx.restore(); }
}
class Particle {
    constructor(type, x, y, angle, speed) {
        this.type = type; this.x = x; this.y = y; this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed; this.life = 1.0;
        if (type === 'wake') { this.size = rnd(5, 12); this.decay = rnd(0.5, 1.2); this.layer = 0; } else if (type === 'fire') { this.size = rnd(3, 8); this.decay = rnd(2.0, 4.0); this.layer = 1; this.vx += (Math.random()-0.5)*2; this.vy += (Math.random()-0.5)*2; } else if (type === 'smoke') { this.size = rnd(10, 20); this.decay = rnd(0.5, 1.0); this.layer = 1; }
    }
    update(dt) { this.x += this.vx; this.y += this.vy; this.life -= this.decay * dt; if (this.type === 'wake') { this.size += 0.2; this.vx *= 0.9; this.vy *= 0.9; } else if (this.type === 'smoke') { this.size += 0.2; this.vx *= 0.95; this.vy *= 0.95; } }
    draw(ctx) { ctx.save(); ctx.translate(this.x, this.y); const alpha = Math.max(0, this.life); if (this.type === 'wake') { ctx.fillStyle = `rgba(180, 230, 255, ${alpha * 0.3})`; ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI * 2); ctx.fill(); } else if (this.type === 'fire') { ctx.globalCompositeOperation = 'lighter'; ctx.fillStyle = `rgba(255, ${Math.floor(alpha * 150)}, 0, ${alpha})`; ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size); } else if (this.type === 'smoke') { ctx.fillStyle = `rgba(50, 50, 50, ${alpha * 0.5})`; ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI * 2); ctx.fill(); } ctx.restore(); }
}
const game = new Game();
</script>
</body>
</html>
